from typing import (
    overload,
    Tuple,
    Any,
    List,
    Iterable,
    Iterator,
    Optional,
    TypeVar,
    Union,
    Sequence,
)
from .z3types import Ast, ContextObj

class Context: ...
class Z3PPObject: ...

class AstRef(Z3PPObject):
    @overload
    def __init__(self, ast: Ast, ctx: Context) -> None:
        self.ast: Ast = ...
        self.ctx: Context = ...
    @overload
    def __init__(self, ast: Ast) -> None:
        self.ast: Ast = ...
        self.ctx: Context = ...
    def ctx_ref(self) -> ContextObj: ...
    def as_ast(self) -> Ast: ...
    def children(self) -> List[AstRef]: ...
    def eq(self, other: AstRef) -> bool: ...
    # TODO: Cannot add __eq__ currently: mypy complains conflict with
    # object.__eq__ signature
    # def __eq__(self, other: object) -> ArithRef:  ...

class SortRef(AstRef): ...

class FuncDeclRef(AstRef):
    def arity(self) -> int: ...
    def name(self) -> str: ...
    def __call__(self, *args: ExprRef) -> ExprRef: ...

class ExprRef(AstRef):
    def sort(self) -> SortRef: ...
    def decl(self) -> FuncDeclRef: ...

class BoolSortRef(SortRef): ...
class ArraySortRef(SortRef): ...
class FPSortRef(SortRef): ...
class BoolRef(ExprRef): ...

def is_true(a: AstRef) -> bool: ...
def is_false(a: AstRef) -> bool: ...
def is_int_value(a: AstRef) -> bool: ...
def substitute(a: AstRef, *m: Tuple[AstRef, AstRef]) -> AstRef: ...

@overload
def simplify(a: BoolRef, *args: Any, **kwargs: Any) -> BoolRef: ...
@overload
def simplify(a: BitVecRef, *args: Any, **kwargs: Any) -> BitVecRef: ...
@overload
def simplify(a: FPRef, *args: Any, **kwargs: Any) -> FPRef: ...
@overload
def simplify(a: AstRef, *args: Any, **kwargs: Any) -> AstRef: ...

class ArithSortRef(SortRef): ...

class ArithRef(ExprRef):
    def __neg__(self) -> ExprRef: ...
    def __le__(self, other: ArithRef) -> BoolRef: ...
    def __lt__(self, other: ArithRef) -> BoolRef: ...
    def __ge__(self, other: ArithRef) -> BoolRef: ...
    def __gt__(self, other: ArithRef) -> BoolRef: ...
    def __add__(self, other: ArithRef) -> ArithRef: ...
    def __sub__(self, other: ArithRef) -> ArithRef: ...
    def __mul__(self, other: ArithRef) -> ArithRef: ...
    def __div__(self, other: ArithRef) -> ArithRef: ...
    def __truediv__(self, other: ArithRef) -> ArithRef: ...
    def __mod__(self, other: ArithRef) -> ArithRef: ...

class BitVecSortRef(SortRef): ...

class BitVecRef(ExprRef):
    def size(self) -> int: ...
    def __add__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __radd__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __mul__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __rmul__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __sub__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __rsub__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __or__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __ror__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __and__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __rand__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __xor__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __rxor__(self, other: Union[BitVecRef, int]) -> BitVecRef: ...
    def __pos__(self) -> BitVecRef: ...
    def __neg__(self) -> BitVecRef: ...
    def __invert__(self) -> BitVecRef: ...
    def __div__(self, other: BitVecRef) -> BitVecRef: ...
    def __rdiv__(self, other: BitVecRef) -> BitVecRef: ...
    def __truediv__(self, other: BitVecRef) -> BitVecRef: ...
    def __rtruediv__(self, other: BitVecRef) -> BitVecRef: ...
    def __mod__(self, other: BitVecRef) -> BitVecRef: ...
    def __rmod__(self, other: BitVecRef) -> BitVecRef: ...
    def __le__(self, other: BitVecRef) -> BoolRef: ...
    def __lt__(self, other: BitVecRef) -> BoolRef: ...
    def __ge__(self, other: BitVecRef) -> BoolRef: ...
    def __gt__(self, other: BitVecRef) -> BoolRef: ...
    def __rshift__(self, other: BitVecRef) -> BitVecRef: ...
    def __lshift__(self, other: BitVecRef) -> BitVecRef: ...
    def __rrshift__(self, other: BitVecRef) -> BitVecRef: ...
    def __rlshift__(self, other: BitVecRef) -> BitVecRef: ...

class BitVecNumRef(BitVecRef):
    def as_long(self) -> int: ...
    def as_signed_long(self) -> int: ...
    def as_string(self) -> str: ...

class IntNumRef(ArithRef):
    def as_long(self) -> int: ...
    def as_string(self) -> str: ...

class SeqSortRef(ExprRef): ...
class SeqRef(ExprRef): ...
class ReSortRef(ExprRef): ...
class ReRef(ExprRef): ...
class ArrayRef(ExprRef): ...

class FPRef(ExprRef):
    def ebits(self) -> int: ...
    def sbits(self) -> int: ...
    def __neg__(self) -> FPRef: ...
    def __le__(self, other: FPRef) -> BoolRef: ...
    def __lt__(self, other: FPRef) -> BoolRef: ...
    def __ge__(self, other: FPRef) -> BoolRef: ...
    def __gt__(self, other: FPRef) -> BoolRef: ...
    def __add__(self, other: FPRef) -> FPRef: ...
    def __radd__(self, other: FPRef) -> FPRef: ...
    def __sub__(self, other: FPRef) -> FPRef: ...
    def __rsub__(self, other: FPRef) -> FPRef: ...
    def __mul__(self, other: FPRef) -> FPRef: ...
    def __rmul__(self, other: FPRef) -> FPRef: ...
    def __mod__(self, other: FPRef) -> FPRef: ...
    def __rmod__(self, other: FPRef) -> FPRef: ...

class FPNumRef(FPRef):
    ...

class FPRMRef(ExprRef):
    ...

class CheckSatResult: ...

class ModelRef(Z3PPObject):
    def __getitem__(self, k: FuncDeclRef) -> ExprRef: ...
    def decls(self) -> Iterable[FuncDeclRef]: ...
    def __iter__(self) -> Iterator[FuncDeclRef]: ...

class FuncEntry:
    def num_args(self) -> int: ...
    def arg_value(self, idx: int) -> ExprRef: ...
    def value(self) -> ExprRef: ...

class FuncInterp(Z3PPObject):
    def else_value(self) -> ExprRef: ...
    def num_entries(self) -> int: ...
    def arity(self) -> int: ...
    def entry(self, idx: int) -> FuncEntry: ...

class Goal(Z3PPObject): ...

class Solver(Z3PPObject):
    ctx: Context
    def __init__(self, ctx: Optional[Context] = None) -> None: ...
    def to_smt2(self) -> str: ...
    def check(self) -> CheckSatResult: ...
    def push(self) -> None: ...
    def pop(self, num: Optional[int] = 1) -> None: ...
    def model(self) -> ModelRef: ...
    def set(self, *args: Any, **kwargs: Any) -> None: ...
    @overload
    def add(self, *args: Union[BoolRef, Goal]) -> None: ...
    @overload
    def add(self, args: Sequence[Union[BoolRef, Goal]]) -> None: ...
    def reset(self) -> None: ...

class Optimize(Z3PPObject):
    ctx: Context
    def __init__(self, ctx: Optional[Context] = None) -> None: ...
    def check(self) -> CheckSatResult: ...
    def push(self) -> None: ...
    def pop(self) -> None: ...
    def model(self) -> ModelRef: ...
    def set(self, *args: Any, **kwargs: Any) -> None: ...
    @overload
    def add(self, *args: Union[BoolRef, Goal]) -> None: ...
    @overload
    def add(self, args: Sequence[Union[BoolRef, Goal]]) -> None: ...
    def minimize(self, element: ExprRef) -> None: ...
    def maximize(self, element: ExprRef) -> None: ...

sat: CheckSatResult = ...
unsat: CheckSatResult = ...
@overload
def Int(name: str) -> ArithRef: ...
@overload
def Int(name: str, ctx: Context) -> ArithRef: ...
@overload
def Bool(name: str) -> BoolRef: ...
@overload
def Bool(name: str, ctx: Context) -> BoolRef: ...
@overload
def parse_smt2_string(s: str) -> ExprRef: ...
@overload
def parse_smt2_string(s: str, ctx: Context) -> ExprRef: ...
def Array(name: str, domain: SortRef, range: SortRef) -> ArrayRef: ...
def K(domain: SortRef, v: Union[ExprRef, int, bool, str]) -> ArrayRef: ...

# Can't give more precise types here since func signature is
# a vararg list of ExprRef optionally followed by a Context
def Or(*args: Any) -> BoolRef: ...
def And(*args: Any) -> BoolRef: ...
def Not(p: BoolRef, ctx: Optional[Context] = None) -> BoolRef: ...
def Implies(a: BoolRef, b: BoolRef, ctx: Context) -> BoolRef: ...

T = TypeVar("T", bound=ExprRef)

def If(a: BoolRef, b: T, c: T, ctx: Optional[Context] = None) -> T: ...
def ULE(a: T, b: T) -> BoolRef: ...
def ULT(a: T, b: T) -> BoolRef: ...
def UGE(a: T, b: T) -> BoolRef: ...
def UGT(a: T, b: T) -> BoolRef: ...
def UDiv(a: T, b: T) -> T: ...
def URem(a: T, b: T) -> T: ...
def SRem(a: T, b: T) -> T: ...
def LShR(a: T, b: T) -> T: ...
def RotateLeft(a: T, b: T) -> T: ...
def RotateRight(a: T, b: T) -> T: ...
def SignExt(n: int, a: BitVecRef) -> BitVecRef: ...
def ZeroExt(n: int, a: BitVecRef) -> BitVecRef: ...
@overload
def Concat(args: List[Union[SeqRef, str]]) -> SeqRef: ...
@overload
def Concat(*args: Union[SeqRef, str]) -> SeqRef: ...
@overload
def Concat(args: List[ReRef]) -> ReRef: ...
@overload
def Concat(*args: ReRef) -> ReRef: ...
@overload
def Concat(args: List[BitVecRef]) -> BitVecRef: ...
@overload
def Concat(*args: BitVecRef) -> BitVecRef: ...
@overload
def Extract(
    high: Union[SeqRef], lo: Union[int, ArithRef], a: Union[int, ArithRef]
) -> SeqRef: ...
@overload
def Extract(
    high: Union[int, ArithRef], lo: Union[int, ArithRef], a: BitVecRef
) -> BitVecRef: ...
@overload
def Sum(arg: BitVecRef, *args: Union[BitVecRef, int]) -> BitVecRef: ...
@overload
def Sum(arg: Union[List[BitVecRef], int]) -> BitVecRef: ...
@overload
def Sum(arg: ArithRef, *args: Union[ArithRef, int]) -> ArithRef: ...

# FP Funcs
def RoundNearestTiesToEven(ctx: Optional[Context] = None) -> FPRMRef:    ...
def RoundNearestTiesToAway(ctx: Optional[Context] = None) -> FPRMRef:    ...
def RoundTowardPositive(ctx: Optional[Context] = None) -> FPRMRef:    ...
def RoundTowardNegative(ctx: Optional[Context] = None) -> FPRMRef:    ...
def RoundTowardZero(ctx: Optional[Context] = None) -> FPRMRef:    ...

def fpIsNaN(arg: FPRef, ctx: Optional[Context] = None) -> BoolRef: ...
def fpIsInf(arg: FPRef, ctx: Optional[Context] = None) -> BoolRef: ...
def fpToSBV(rm: FPRMRef, x: FPRef, s: BitVecSortRef, ctx: Optional[Context] = None) -> BitVecRef:   ...
def fpToUBV(rm: FPRMRef, x: FPRef, s: BitVecSortRef, ctx: Optional[Context] = None) -> BitVecRef:   ...
def fpFPToFP(rm: FPRMRef, x: FPRef, s: FPSortRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpUnsignedToFP(rm: FPRMRef, x: BitVecRef, s: FPSortRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpSignedToFP(rm: FPRMRef, x: BitVecRef, s: FPSortRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpAbs(x: FPRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpNeg(x: FPRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpSqrt(rm: FPRMRef, a: FPRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpAdd(rm: FPRMRef, a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpSub(rm: FPRMRef, a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpMul(rm: FPRMRef, a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpDiv(rm: FPRMRef, a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpMin(a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpMax(a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpEQ(a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> BoolRef:   ...
def fpNEQ(a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> BoolRef:   ...
def fpLT(a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> BoolRef:   ...
def fpLEQ(a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> BoolRef:   ...
def fpGT(a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> BoolRef:   ...
def fpGEQ(a: FPRef, b: FPRef, ctx: Optional[Context] = None) -> BoolRef:   ...
def fpRoundToIntegral(rm: FPRMRef, a: FPRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpBVToFP(v: BitVecRef, s: FPSortRef, ctx: Optional[Context] = None) -> FPRef:   ...
def fpToIEEEBV(v: FPRef, ctx: Optional[Context] = None) -> BitVecRef:   ...
def is_fp_value(v: AstRef) -> bool: ...
def is_bv_value(v: AstRef) -> bool: ...
def fpZero(s: FPSortRef, negative: bool) -> FPRef:   ...
def fpPlusZero(s: FPSortRef) -> FPRef: ...
def RNE(ctx: Optional[Context] = None) -> FPRMRef:  ...

# Can't include this overload as it overlaps with the second overload.
# @overload
# def Sum(arg: Union[List[ArithRef], int]) -> ArithRef:  ...

def Function(name: str, *sig: SortRef) -> FuncDeclRef: ...
def IntVal(val: int, ctx: Optional[Context] = None) -> IntNumRef: ...
def BoolVal(val: bool, ctx: Optional[Context] = None) -> BoolRef: ...
# DIMO(This def omits the exp argument which seems to be unused in the code)
def FPVal(val: Union[int,float,str], fps: FPSortRef, ctx: Optional[Context] = None) -> FPRef: ...
def BitVecVal(
    val: int, bv: Union[int, BitVecSortRef], ctx: Optional[Context] = None
) -> BitVecRef: ...
def BitVec(
    val: str, bv: Union[int, BitVecSortRef], ctx: Optional[Context] = None
) -> BitVecRef: ...
def IntSort(ctx: Optional[Context] = None) -> ArithSortRef: ...
def BoolSort(ctx: Optional[Context] = None) -> BoolSortRef: ...
def ArraySort(domain: SortRef, range: SortRef) -> ArraySortRef: ...
def BitVecSort(domain: int, ctx: Optional[Context] = None) -> BitVecSortRef: ...
def Float16(ctx: Optional[Context] = None) -> FPSortRef: ...
def FloatHalf(ctx: Optional[Context] = None) -> FPSortRef: ...
def Float32(ctx: Optional[Context] = None) -> FPSortRef: ...
def FloatSingle(ctx: Optional[Context] = None) -> FPSortRef: ...
def Float64(ctx: Optional[Context] = None) -> FPSortRef: ...
def FloatDouble(ctx: Optional[Context] = None) -> FPSortRef: ...
def Float128(ctx: Optional[Context] = None) -> FPSortRef: ...
def FloatQuadruple(ctx: Optional[Context] = None) -> FPSortRef: ...
def ForAll(vs: List[ExprRef], expr: ExprRef) -> ExprRef: ...
def Select(arr: ArrayRef, ind: ExprRef) -> ExprRef: ...
def Update(arr: ArrayRef, ind: ExprRef, newVal: ExprRef) -> ArrayRef: ...
def Store(arr: ArrayRef, ind: ExprRef, newVal: ExprRef) -> ArrayRef: ...
def BVAddNoOverflow(a: BitVecRef, b: BitVecRef, signed: bool) -> BoolRef: ...
def BVAddNoUnderflow(a: BitVecRef, b: BitVecRef) -> BoolRef: ...
def BVSubNoOverflow(a: BitVecRef, b: BitVecRef) -> BoolRef: ...
def BVSubNoUnderflow(a: BitVecRef, b: BitVecRef, signed: bool) -> BoolRef: ...
def BVSDivNoOverflow(a: BitVecRef, b: BitVecRef) -> BoolRef: ...
def BVSNegNoOverflow(a: BitVecRef) -> BoolRef: ...
def BVMulNoOverflow(a: BitVecRef, b: BitVecRef, signed: bool) -> BoolRef: ...
def BVMulNoUnderflow(a: BitVecRef, b: BitVecRef) -> BoolRef: ...